# Анализ сопоставления моделей
# Описание и цели документа
**Цель:**
Этот документ представляет собой детальный анализ сопоставления (маппинга) между сущностями из облачной платформы (источник) и целевой метамоделью архитектуры SEAF. Основная задача — выявить концептуальные несостыковки, определить
логику преобразования данных и дать рекомендации для автоматической конвертации.
**Назначение:**
Анализ и рекомендации, изложенные в этом документе, предназначены для дальнейшего использования в качестве контекста для моделей ИИ (LLM), которые будут выполнять задачу по автоматической конвертации данных из одного представления
в другое.
**Источники данных:**
1.  **Исходные сущности (примеры данных):** Данные из `architecture/ta/reverse/cloud.ru/advanced/*.yaml`.
2.  **Схемы исходных сущностей:** Метамодель, описанная в `_metamodel_/iaas/cloud.ru/advanced/entities/*.yaml`.
3.  **Целевые сущности:** Метамодель архитектурного фреймворка SEAF, описанная в `_metamodel_/seaf-core/entities/ta/**/*.yaml`.

---

### tenant
- **Сущность-источник:** `tenant` (атрибут в различных сущностях)
- **Целевая сущность:** Не конвертируется.
- **Описание сопоставления:** Информация о тенанте используется для группировки ресурсов, но не преобразуется в отдельную сущность в целевой модели.
- **Возможные несостыковки:** Отсутствуют, так как прямого сопоставления нет.
- **Рекомендации:** Нет.

---

### branches
- **Сущность-источник:** `seaf.ta.reverse.cloud.ru.advanced.branches`
- **Целевая сущность:** `seaf.ta.services.office`
- **Описание сопоставления:** `branch_id` в `seaf.ta.reverse.cloud_ru.advanced.vpn_connections` ссылается на офисы, описанные в `seaf.ta.reverse.cloud.ru.advanced.branches`.

**Анализ сопоставления свойств:**

| Свойство в `branches` | Свойство в `seaf.ta.services.office` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `location` | `address` | Прямое сопоставление. `location` из `branches` можно записать в `address`. |
| `id` | `external_id` | `id` из `branches` можно использовать как внешний идентификатор. |
| `country`, `city` | `region` (ссылка на `seaf.ta.services.dc_region`) | **Несостыковка.** В `office` используется ссылка на регион, а в `branches` — отдельные поля для страны и города. |
| `symbol` | (нет) | Это свойство относится к визуализации и не имеет аналога в целевой модели данных. |
| (нет) | `description` | В `branches` нет поля для описания. |

**Ключевые несостыковки и рекомендации:**

1.  **Структура адреса:**
    *   **Проблема:** `branches` использует три поля (`country`, `city`, `location`), тогда как `office` использует одно поле `address` и ссылку на `region`.
    *   **Рекомендация:** При конвертации можно объединить `country`, `city`, `location` в одну строку и записать в `address`. Для поля `region` потребуется дополнительная логика: нужно будет найти или создать соответствующий объект `seaf.ta.services.dc_region` на основе данных из `country` и `city`.

2.  **Отсутствующие поля:**
    *   **Проблема:** В `branches` нет поля `description`.
    *   **Рекомендация:** При конвертации поле `description` в `office` останется пустым, если не будет введено вручную.

---

### dc_az
- **Сущность-источник:** Различные сущности (ecss, cces, rdss, dmss)
- **Целевая сущность:** `seaf.ta.services.dc_az`
- **Описание сопоставления:** Зоны доступности (AZ) из различных облачных ресурсов собираются и преобразуются в отдельные сущности `dc_az`.

**Анализ сопоставления свойств:**

| Свойство в источнике | Свойство в `seaf.ta.services.dc_az` | Комментарий |
| :--- | :--- | :--- |
| `az_name` (из ecss.az, cces.masters_az, rdss.az, dmss.available_az) | `title` | Прямое сопоставление. |
| `az_name` | `external_id` | Прямое сопоставление. |
| (статическое значение) | `vendor` | Установить в "Cloud.ru". |
| `az_name` | `region` | **Ключевая логика.** Регион вычисляется из имени AZ (например, `ru-moscow-1c` -> `ru-moscow-1`). Необходимо найти или создать соответствующую сущность `seaf.ta.services.dc_region`. |

**Ключевые моменты и рекомендации:**

1.  **Сбор уникальных AZ:**
    *   **Логика:** AZ могут встречаться в различных сущностях. Необходимо собрать все уникальные имена AZ из `ecss.az`, `ecss.disks.az`, `cces.masters_az`, `rdss.az`, `dmss.available_az`.
    *   **Рекомендация:** Создать отдельный конвертер (`dc_az_converter.py`), который будет агрегировать эти данные.

2.  **Вычисление региона:**
    *   **Логика:** Имя региона не всегда явно присутствует в исходных данных, но может быть выведено из имени AZ.
    *   **Рекомендация:** Реализовать функцию для извлечения имени региона из имени AZ (например, отбросить последнюю букву, если она является частью обозначения зоны).

3.  **Создание `dc_region`:**
    *   **Логика:** Сущность `dc_az` требует ссылку на `seaf.ta.services.dc_region`. Эти сущности также должны быть созданы.
    *   **Рекомендация:** Предполагается, что `dc_region` будут созданы отдельным конвертером или будут существовать заранее. Для текущей реализации, ссылка на `dc_region` будет формироваться по имени (например, `flix.dc_region.ru-moscow-1`).

---

### cces
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.cces`
- **Целевая сущность:** `seaf.ta.services.k8s`
- **Описание сопоставления:** Кластеры Kubernetes из Cloud.ru (CCE) отображаются в сущность "Кластер Kubernetes" (`seaf.ta.services.k8s`).

**Анализ сопоставления свойств:**

| Свойство в `cces` | Свойство в `seaf.ta.services.k8s` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `alias` | `description` | Можно использовать `alias` для заполнения `description`. |
| `id` | `external_id` | Прямое сопоставление. |
| `endpoints` (url) | `fqdn` | Можно взять URL из `endpoints` в качестве FQDN. |
| `version` | `software` | Можно составить строку, например, "CCE " + `version`. |
| `masters_az` | `availabilityzone` | Необходимо найти объекты `seaf.ta.services.dc_az` по строковым именам и сформировать массив ссылок. |
| `DC` | `location` | Прямое сопоставление ссылки. |
| `subnet_id` | `network_connection` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `service_network` | `management_networks` | Необходимо создать `seaf.ta.services.network` на основе CIDR и сформировать массив из одной ссылки. |
| `supportistio` | `service_mesh` | Можно установить значение `service_mesh` в "istio", если `supportistio` равно `true`. |
| `authentication` | `auth` | Необходимо найти/создать объект `seaf.ta.services.kb` по строке `authentication` и сослаться на него. |
| `flavor`, `platform_version`, `addresses`, `security_groups`, `container_network`, `tenant` | (нет) | Эти поля не имеют прямых аналогов в целевой сущности. |
| (нет) | `is_own`, `cni`, `cluster_autoscaler`, `keys`, `idm`, `policy`, `pam`, `ca`, `audit`, `audit_policy`, `monitoring`, `backup`, `registries` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Связь с VPC (`vpc_id`):**
    *   **Логика:** Поле `vpc_id` не отображается напрямую в свойство кластера `k8s`. Оно используется для подтверждения, что подсеть (`subnet_id`), к которой подключен кластер, принадлежит правильному сетевому сегменту (`network_segment`), который создается из VPC. Эта связь устанавливается при конвертации `subnet` -> `network`.

2.  **Преобразование ссылок:**
    *   **Логика:** Для полей `masters_az`, `subnet_id`, `service_network`, `authentication` требуется логика поиска/создания целевых объектов (`dc_az`, `network`, `kb`) и формирования на них ссылок.

3.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию из `cces`, не имеющую аналогов (например, `flavor`, `platform_version`), можно поместить в поле `description`. Поля в `k8s`, для которых нет данных в `cces` (например, `cni`, `monitoring`), должны быть заполнены вручную или на основе правил по умолчанию (например, `is_own: true`).

---

### dmss
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.dmss`
- **Целевая сущность:** `seaf.ta.services.cluster`
- **Описание сопоставления:** Сервис очередей (Kafka/RabbitMQ) отображается в общий кластер с соответствующим `service_type`.

**Анализ сопоставления свойств:**

| Свойство в `dmss` | Свойство в `seaf.ta.services.cluster` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `engine` | `service_type` | Установить `service_type` в "Интеграционная шина (MQ, ETL, API)". Значение `engine` (rabbitmq/kafka) поместить в `description`. |
| `address` | `fqdn` | Можно использовать IP-адрес в качестве FQDN. |
| `available_az` | `availabilityzone` | Необходимо найти объекты `seaf.ta.services.dc_az` по строковым именам и сформировать массив ссылок. |
| `DC` | `location` | Прямое сопоставление ссылки. |
| `subnet_id` | `network_connection` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `type` | `reservation_type` | `type` (например, "single") можно сопоставить с `reservation_type`. |
| `engine_version`, `port`, `status`, `specification`, `security_groups`, `storage_space`, `total_storage_space`, `used_storage_space`, `storage_spec_code`, `management`, `support_features`, `node_num`, `disk_encrypted`, `tenant` | (нет) | Эти поля не имеют прямых аналогов в целевой сущности. |

**Ключевые моменты и рекомендации:**

1.  **Связь с VPC (`vpc_id`):**
    *   **Логика:** Поле `vpc_id` не отображается напрямую в свойство кластера. Оно подтверждает принадлежность `subnet_id` к правильному сетевому сегменту (`network_segment`), который создается из VPC.

2.  **Преобразование ссылок:**
    *   **Логика:** Для полей `available_az` и `subnet_id` требуется логика поиска/создания целевых объектов (`dc_az`, `network`) и формирования на них ссылок.

3.  **Детализация в описании:**
    *   **Рекомендация:** Большое количество специфичных для `dmss` атрибутов (версии, хранилище, спецификации) следует поместить в поле `description` в структурированном виде (например, Markdown) для сохранения полноты информации.

---

### dc_region
- **Сущность-источник:** Различные сущности (ecss, cces, rdss, dmss) через AZ
- **Целевая сущность:** `seaf.ta.services.dc_region`
- **Описание сопоставления:** Регионы, выведенные из имен зон доступности (AZ), преобразуются в отдельные сущности `dc_region`.

**Анализ сопоставления свойств:**

| Свойство в источнике | Свойство в `seaf.ta.services.dc_region` | Комментарий |
| :--- | :--- | :--- |
| `region_name` (выведен из AZ) | `title` | Прямое сопоставление. |
| `region_name` | `external_id` | Прямое сопоставление. |

**Ключевые моменты и рекомендации:**

1.  **Сбор уникальных регионов:**
    *   **Логика:** Регионы выводятся из имен AZ, которые встречаются в различных сущностях. Необходимо собрать все уникальные имена регионов.
    *   **Рекомендация:** Создать отдельный конвертер (`dc_region_converter.py`), который будет агрегировать эти данные.

2.  **Вычисление региона:**
    *   **Логика:** Имя региона выводится из имени AZ (например, `ru-moscow-1c` -> `ru-moscow-1`).
    *   **Рекомендация:** Использовать ту же логику вывода региона, что и для `dc_az`.

---

### dc_az
- **Сущность-источник:** Различные сущности (ecss, cces, rdss, dmss)
- **Целевая сущность:** `seaf.ta.services.dc_az`
- **Описание сопоставления:** Зоны доступности (AZ) из различных облачных ресурсов собираются и преобразуются в отдельные сущности `dc_az`.

**Анализ сопоставления свойств:**

| Свойство в источнике | Свойство в `seaf.ta.services.dc_az` | Комментарий |
| :--- | :--- | :--- |
| `az_name` (из ecss.az, cces.masters_az, rdss.az, dmss.available_az) | `title` | Прямое сопоставление. |
| `az_name` | `external_id` | Прямое сопоставление. |
| (статическое значение) | `vendor` | Установить в "Cloud.ru". |
| `az_name` | `region` | **Ключевая логика.** Регион вычисляется из имени AZ (например, `ru-moscow-1c` -> `ru-moscow-1`). Необходимо найти или создать соответствующую сущность `seaf.ta.services.dc_region`. |

**Ключевые моменты и рекомендации:**

1.  **Сбор уникальных AZ:**
    *   **Логика:** AZ могут встречаться в различных сущностях. Необходимо собрать все уникальные имена AZ из `ecss.az`, `ecss.disks.az`, `cces.masters_az`, `rdss.az`, `dmss.available_az`.
    *   **Рекомендация:** Создать отдельный конвертер (`dc_az_converter.py`), который будет агрегировать эти данные.

2.  **Вычисление региона:**
    *   **Логика:** Имя региона не всегда явно присутствует в исходных данных, но может быть выведено из имени AZ.
    *   **Рекомендация:** Реализовать функцию для извлечения имени региона из имени AZ (например, отбросить последнюю букву, если она является частью обозначения зоны).

3.  **Создание `dc_region`:**
    *   **Логика:** Сущность `dc_az` требует ссылку на `seaf.ta.services.dc_region`. Эти сущности также должны быть созданы.
    *   **Рекомендация:** Предполагается, что `dc_region` будут созданы отдельным конвертером или будут существовать заранее. Для текущей реализации, ссылка на `dc_region` будет формироваться по имени (например, `flix.dc_region.ru-moscow-1`).

### ecss
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.ecss`
- **Целевая сущность:** `seaf.ta.components.server`
- **Описание сопоставления:** Виртуальные машины (Elastic Cloud Server) отображаются в сущность "Сервер".

**Анализ сопоставления свойств:**

| Свойство в `ecss` | Свойство в `seaf.ta.components.server` | Комментарий |
| :--- | :--- | :--- |
| `name` | `fqdn` / `title` | Прямое сопоставление. |
| `description` | `description` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `os.type`, `os.bit` | `os.type`, `os.bit` | Прямое сопоставление. |
| `cpu.cores`, `cpu.frequency` | `cpu.cores`, `cpu.frequency` | Прямое сопоставление. |
| `ram` | `ram` | Необходимо конвертировать MB в GB (разделить на 1024). |
| `nic_qty` | `nic_qty` | Прямое сопоставление. |
| `disks` | `disks` | Структура объектов в массиве разная, требуется приведение к единому формату. |
| `az` | `az` | Необходимо найти объект `seaf.ta.services.dc_az` по строковому имени и поместить ссылку в массив. |
| `subnets` | `subnets` | Для каждого ID из `ecss.subnets` нужно найти/создать `seaf.ta.services.network` и добавить ссылку в массив. |
| `type` | `type` | Прямое сопоставление (`vm` -> "Виртуальный"). |
| (статическое значение) | `is_part_of_cluster_virtualization` | Ссылка на единый кластер виртуализации. |
| `flavor`, `status`, `addresses`, `security_groups`, `tags`, `tenant`, `DC` | (нет) | Эти поля не имеют прямых аналогов в целевой сущности. |
| (нет) | `virtualization`, `is_part_of_...`, `software` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Связь с VPC (`vpc_id`):**
    *   **Логика:** Поле `vpc_id` не отображается напрямую в свойство сервера. Оно подтверждает принадлежность `subnets` к правильному сетевому сегменту (`network_segment`), который создается из VPC.

2.  **Преобразование данных и ссылок:**
    *   **Логика:** Необходимо реализовать конвертацию `ram` (MB в GB), а также логику поиска целевых объектов для `az` и `subnets` для формирования ссылок.

3.  **Детализация в описании:**
    *   **Рекомендация:** Важную информацию без прямых аналогов (`flavor`, `status`, `tags` и др.) следует поместить в `description` в структурированном виде. Поле `virtualization` (обязательное) нужно будет заполнить на основе `DC` или общих правил.

---

### cluster_virtualization
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.ecss` (неявно, через AZ и сети ВМ)
- **Целевая сущность:** `seaf.ta.services.cluster_virtualization`
- **Описание сопоставления:** Единый кластер виртуализации создается для всех виртуальных машин.

**Анализ сопоставления свойств:**

| Свойство в источнике | Свойство в `seaf.ta.services.cluster_virtualization` | Комментарий |
| :--- | :--- | :--- |
| (статическое значение) | `title` | Установить в "Cloud.ru Virtualization Cluster". |
| (статическое значение) | `external_id` | Установить в "cloud_ru_virtualization_cluster". |
| (статическое значение) | `hypervisor` | Установить в "Cloud.ru Hypervisor". |
| `ecss.az`, `ecss.disks.az` | `availabilityzone` | Собрать все уникальные AZ из всех ВМ и дисков, преобразовать в ссылки на `dc_az`. |
| `ecss.subnets` | `network_connection` | Собрать все уникальные сетевые подключения (подсети) из всех ВМ, преобразовать в ссылки на `network`. |
| (нет) | `oversubscription_rate`, `drs_support`, `sdrs_support`, `location` | Эти поля не имеют прямых аналогов в источнике. |

**Ключевые моменты и рекомендации:**

1.  **Единый кластер:**
    *   **Логика:** Создается только одна сущность `cluster_virtualization` для всего облака.
    *   **Рекомендация:** Реализовать отдельный конвертер (`cluster_virtualization_converter.py`), который будет агрегировать эти данные.

2.  **Связь с ВМ:**
    *   **Логика:** Каждая ВМ (`ecss`) должна ссылаться на этот кластер виртуализации.
    *   **Рекомендация:** В конвертере `ecss` добавить поле `is_part_of_cluster_virtualization` со ссылкой на созданный кластер.

---

### eips
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.eips`
- **Целевая сущность:** `seaf.ta.services.network` (с типом WAN)
- **Описание сопоставления:** Elastic IP (публичный IP-адрес) рассматривается как внешняя сеть.

**Анализ сопоставления свойств:**

| Свойство в `eips` | Свойство в `seaf.ta.services.network` | Комментарий |
| :--- | :--- | :--- |
| `ext_address` | `title` | Можно использовать внешний IP в качестве имени. |
| `id` | `external_id` | Прямое сопоставление. |
| `ext_address` | `wan_ip` | Прямое сопоставление. |
| (статическое значение) | `type` | Установить в "WAN". |
| `int_address` | `segment` | **Ключевая логика.** Необходимо найти подсеть (`subnet`), в CIDR которой входит `int_address`. Из найденной подсети взять `vpc_id` и по нему найти соответствующий `network_segment`. |
| `limit.throughput` | `description` | Пропускную способность и другие детали можно добавить в описание. |
| `type`, `port_id`, `int_address`, `tenant`, `DC` | `description` | Эти поля не имеют прямых аналогов и могут быть добавлены в описание для полноты. |

**Ключевые моменты и рекомендации:**

1.  **Вычисление сегмента:**
    *   **Логика:** Связь EIP с сегментом сети непрямая. Она определяется через его внутренний IP-адрес (`int_address`). Необходимо реализовать логику, которая для каждого `int_address` находит соответствующую подсеть (`subnet`) путем проверки вхождения IP в CIDR подсети. После нахождения подсети, из нее извлекается `vpc_id`, который используется для ссылки на `network_segment`.
    *   **Рекомендация:** Использовать стандартную библиотеку `ipaddress` для надежной проверки вхождения IP-адреса в CIDR-диапазон.

---

### elbs
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.elbs`
- **Целевая сущность:** `seaf.ta.components.network` (с типом "Балансировщик")
- **Описание сопоставления:** Балансировщик нагрузки (Elastic Load Balance) отображается в сущность "Сетевое устройство".

**Анализ сопоставления свойств:**

| Свойство в `elbs` | Свойство в `seaf.ta.components.network` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` / `fqdn` | Прямое сопоставление. |
| `description` | `description` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| (статическое значение) | `type` | Установить в "Балансировщик". |
| `subnet_id` | `subnets` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `listeners`, `pools`, `forwardingpolicy` | (нет) | **Ключевая несостыковка.** Это сложная конфигурация, определяющая логику работы балансировщика. |
| `subnet_id` (через `subnets`->`vpc`) | `segment` | **Ключевая логика.** Необходимо найти `network_segment`, соответствующий `vpc`, к которому принадлежит `subnet`, и сослаться на него. |
| `address`, `operating_status`, `provisioning_status`, `tags`, `tenant`, `DC` | (нет) | Эти поля не имеют прямых аналогов. |
| (нет) | `ports`, `az`, `virtualization`, `software` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Конфигурация балансировщика (`listeners`, `pools`):**
    *   **Проблема:** Самая важная информация о балансировщике — его `listeners` (какие порты он слушает) и `pools` (на какие серверы он перенаправляет трафик) — не имеет полей в целевой сущности `seaf.ta.components.network`. Модель `network` описывает физическое или виртуальное "железо", но не его детальную конфигурацию.
    *   **Рекомендация 1 (Простая):** Поместить всю сложную структуру `listeners` и `pools` в поле `description` в формате YAML или JSON. Это позволит сохранить данные, но сделает их труднодоступными для автоматического анализа.
    *   **Рекомендация 2 (Сложная, но более корректная):** Расширить метамодель. Создать новые сущности, например, `seaf.ta.components.network.listener` и `seaf.ta.components.network.pool`, и связать их с `seaf.ta.components.network`. Это наиболее точный подход, который позволит полноценно моделировать конфигурацию балансировщика.

2.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию без прямых аналогов (`address`, `status`, `tags` и т.д.) следует поместить в `description` для сохранения контекста.

3.  **Заполнение обязательных полей:**
    *   **Рекомендация:** Необходимо определить логику заполнения полей `az` и `virtualization`. `az` можно определить по `subnet_id`, а `virtualization` — на основе `DC` или общих правил.

---

### nat_gateways
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.nat_gateways`
- **Целевая сущность:** `seaf.ta.components.network` (с типом "NAT")
- **Описание сопоставления:** NAT-шлюз отображается в сущность "Сетевое устройство".

**Анализ сопоставления свойств:**

| Свойство в `nat_gateways` | Свойство в `seaf.ta.components.network` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` / `fqdn` | Прямое сопоставление. |
| `description` | `description` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| (статическое значение) | `type` | Установить в "NAT". |
| `subnet_id` | `subnets` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `snat_rules`, `dnat_rules` | (нет) | **Ключевая несостыковка.** Это сложная конфигурация, определяющая логику работы NAT-шлюза. |
| `subnet_id` (через `subnets`->`vpc`) | `segment` | **Ключевая логика.** Необходимо найти `network_segment`, соответствующий `vpc`, к которому принадлежит `subnet`, и сослаться на него. |
| `address`, `status`, `tenant`, `DC` | (нет) | Эти поля не имеют прямых аналогов. |
| (нет) | `ports`, `az`, `virtualization`, `software` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Правила NAT (`snat_rules`, `dnat_rules`):**
    *   **Проблема:** Аналогично `elbs`, ключевая информация о работе шлюза — его правила SNAT и DNAT — не имеет полей в целевой сущности `seaf.ta.components.network`.
    *   **Рекомендация 1 (Простая):** Поместить всю структуру правил в поле `description` в формате YAML или JSON. Это сохранит данные, но сделает их труднодоступными для автоматического анализа.
    *   **Рекомендация 2 (Сложная, но более корректная):** Расширить метамодель, добавив сущности для правил NAT (например, `seaf.ta.components.network.nat_rule`) и связав их с `seaf.ta.components.network`.

2.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию без прямых аналогов (`address`, `status`, `tenant`, `DC`) следует поместить в `description` для сохранения контекста.

3.  **Заполнение обязательных полей:**
    *   **Рекомендация:** Необходимо определить логику заполнения полей `az` и `virtualization`. `az` можно определить по `subnet_id`, а `virtualization` — на основе `DC` или общих правил.

---

### peerings
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.peerings`
- **Целевая сущность:** `seaf.ta.services.logical_link`
- **Описание сопоставления:** VPC Peering (связь между двумя VPC) отображается в сущность "Логическая связь".

**Анализ сопоставления свойств:**

| Свойство в `peerings` | Свойство в `seaf.ta.services.logical_link` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `description` | `description` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `request_vpc` | `source` | **Ключевая логика.** `request_vpc` становится источником связи. Необходимо найти сущность, соответствующую `request_vpc`, и поместить ссылку на нее. |
| `accept_vpc` | `target` | **Ключевая логика.** `accept_vpc` становится приемником связи. Необходимо найти сущность, соответствующую `accept_vpc`, и поместить ссылку на нее в массив. |
| (статическое значение) | `direction` | Установить в "<==>" (двунаправленная связь). |
| `status`, `tenant`, `DC` | (нет) | Эти поля не имеют прямых аналогов. |

**Ключевые моменты и рекомендации:**

1.  **Разрешение конечных точек (`request_vpc` -> `source`, `accept_vpc` -> `target`):**
    *   **Логика:** Это основная задача при конвертации. `peering` связывает две сущности `vpc`. В целевой модели `logical_link` связывает две сущности через `source` и `target`.
    *   **Рекомендация:** Необходимо сначала выполнить конвертацию всех `vpc`. Как мы обсуждали ранее, `vpc` может быть сконвертирован в `seaf.ta.services.network_segment` или `seaf.ta.components.network`. После того как `vpc` будут сконвертированы, нужно найти соответствующие им новые сущности по `external_id` и установить их как `source` и `target` для `logical_link`.

2.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию о `status`, `tenant`, `DC` можно поместить в `description` для сохранения контекста.

---

### rdss
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.rdss`
- **Целевая сущность:** `seaf.ta.services.cluster` (с типом "СУБД")
- **Описание сопоставления:** Реляционная БД как сервис (RDS) отображается в сущность "Кластер".

**Анализ сопоставления свойств:**

| Свойство в `rdss` | Свойство в `seaf.ta.services.cluster` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `private_ips` | `fqdn` | Можно взять первый IP из массива в качестве FQDN. |
| `type` | `reservation_type` | `type` (например, "Single", "HA") можно сопоставить с `reservation_type`. |
| (статическое значение) | `service_type` | Установить в "СУБД". |
| `az` | `availabilityzone` | Необходимо найти объект `seaf.ta.services.dc_az` по строковому имени и поместить ссылку в массив. |
| `DC` | `location` | Прямое сопоставление ссылки. |
| `subnet_id` | `network_connection` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `datastore`, `volume`, `nodes`, `backup_strategy`, `flavor`, `status`, `public_ips`, `switch_strategy`, `tags`, `tenant` | (нет) | **Ключевая несостыковка.** Большое количество специфичной информации о СУБД. |

**Ключевые моменты и рекомендации:**

1.  **Связь с VPC (`vpc_id`):**
    *   **Логика:** Поле `vpc_id` не отображается напрямую в свойство кластера. Оно подтверждает принадлежность `subnet_id` к правильному сетевому сегменту (`network_segment`), который создается из VPC.

2.  **Детализация СУБД (`datastore`, `nodes`, `volume` и др.):**
    *   **Проблема:** Целевая сущность `cluster` является обобщенной и не содержит полей для специфичной информации о кластере баз данных (тип и версия движка, информация о нодах, дисках, бэкапах).
    *   **Рекомендация:** Всю эту структурированную информацию (`datastore`, `nodes`, `volume`, `backup_strategy`, `flavor`) следует поместить в поле `description` в формате YAML или Markdown. Это позволит сохранить все детали, не усложняя основную модель `cluster`.

3.  **Преобразование ссылок (`az`, `subnet_id`):**
    *   **Логика:** Как и в предыдущих случаях, для полей `az` и `subnet_id` требуется логика поиска соответствующих целевых объектов (`dc_az`, `network`) и формирования на них ссылок.

4.  **Отсутствующие поля:**
    *   **Рекомендация:** Остальную информацию без прямых аналогов (`status`, `tags`, `tenant` и т.д.) также следует добавить в `description`.

---

### security_group
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.security_groups`
- **Целевая сущность:** Нет прямого аналога.
- **Описание:** Группы безопасности представляют собой именованные наборы правил сетевого доступа (stateful firewall), которые применяются к сетевым интерфейсам компонентов (серверов, кластеров и т.д.).

**Проблема:**
В метамодели `seaf-core` отсутствует сущность, которая бы напрямую соответствовала "группе сетевых правил" или "политике межсетевого экрана". Простое игнорирование этой информации приведет к потере критически важных данных о сетевой безопасности.

**Предлагаемые решения:**

#### Вариант 1: Сохранение в описании компонента (Простой)
- **Логика:** Для каждого компонента (`server`, `k8s` и т.д.), к которому применяется `security_group`, найти все правила из этой группы. Сформатировать эти правила в виде таблицы (Markdown) или блока YAML/JSON и добавить в поле `description` соответствующего компонента (`seaf.ta.components.server` и др.).
- **Плюсы:**
    - Легко реализовать.
    - Вся информация сохраняется.
- **Минусы:**
    - **Дублирование данных:** Если одна группа применяется к 100 серверам, ее правила будут 100 раз скопированы.
    - **Неструктурированные данные:** Правила хранятся как текст, что делает невозможным автоматический анализ и запросы (например, "найти все серверы, открытые для мира по порту 22").

#### Вариант 2: Создание новой сущности (Архитектурно верный)
- **Логика:** Расширить метамодель `seaf-core`, добавив новую сущность, например, `seaf.ta.services.firewall_policy`.
    - Эта сущность будет содержать поля `title`, `description` и массив `rules`.
    - Структура правил будет повторять исходную: `direction`, `protocol`, `port`, `remote_ip` и т.д.
    - Компоненты, такие как `server`, получат новое свойство (например, `firewall_policies`), которое будет содержать массив ссылок на эти новые сущности политик.
- **Плюсы:**
    - Корректно моделирует предметную область.
    - Исключает дублирование данных.
    - Позволяет выполнять запросы и анализ правил.
- **Минусы:**
    - Требует изменения основной метамодели, что может быть нежелательно.

#### Вариант 3: Использование `seaf.ta.services.kb` (Компромисс)
- **Логика:** Использовать существующую сущность "База знаний по ИБ" (`seaf.ta.services.kb`).
    - Каждая `security_group` преобразуется в один объект `seaf.ta.services.kb` с определенным типом (например, `type: "Firewall Policy"`).
    - Название и ID группы безопасности сопоставляются с `title` и `external_id`.
    - Сами правила (`rules`) в формате YAML/JSON помещаются в поле `description` этого объекта `kb`.
    - Компоненты (`server` и др.) ссылаются на эти объекты `kb` через существующее поле `integrations` или новое специализированное поле.
- **Плюсы:**
    - Использует существующую метамодель.
    - Избегает дублирования данных.
- **Минусы:**
    - Правила все еще хранятся как неструктурированный текст в `description`, что затрудняет анализ.

**Итоговая рекомендация:**
- **Для долгосрочного развития** архитектурной модели **Вариант 2** является наиболее предпочтительным.
- **Для быстрой реализации** в рамках текущей задачи, если изменение метамодели невозможно, можно использовать **Вариант 1** или **Вариант 3**. Вариант 3 чуть лучше, так как избегает дублирования правил.

---

### subnet
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.subnets`
- **Целевая сущность:** `seaf.ta.services.network` (с типом LAN)
- **Описание сопоставления:** Подсеть VPC отображается в сущность "Сеть" с типом LAN.

**Анализ сопоставления свойств:**

| Свойство в `subnets` | Свойство в `seaf.ta.services.network` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `description` | `description` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `cidr` | `cidr` | Прямое сопоставление. |
| (статическое значение) | `type` | Установить в "LAN". |
| `vpc` | `segment` | **Ключевая логика.** Необходимо найти `network_segment`, соответствующий `vpc`, и сослаться на него. |
| `gateway`, `dns_list`, `tenant`, `DC` | (нет) | Эти поля не имеют прямых аналогов. |
| (нет) | `vlan`, `is_management`, `is_own`, `provider`, `throughput`, `redundancy` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Связь с сегментом (`vpc` -> `segment`):**
    *   **Логика:** `subnet` является частью `vpc`. В целевой модели `network` является частью `network_segment`. Это прямое концептуальное сопоставление.
    *   **Рекомендация:** При конвертации необходимо сначала обработать все `vpc` и создать для них `network_segment`. Затем, при обработке `subnet`, нужно найти соответствующий `network_segment` по `external_id` (который будет равен ID исходного `vpc`) и установить ссылку в поле `segment`.

2.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию о `gateway`, `dns_list`, `tenant` и `DC` следует поместить в `description` для сохранения контекста.

---

### vaults
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.vaults`
- **Целевая сущность:** `seaf.ta.services.storage` и `seaf.ta.services.backup`
- **Описание сопоставления:** `vault` представляет собой одновременно и хранилище для резервных копий, и информацию о самих копиях. Это требует комбинированного подхода при конвертации.

**Анализ сопоставления свойств:**

| Свойство в `vaults` | Свойство в целевых сущностях | Комментарий |
| :--- | :--- | :--- |
| `name` | `storage.title` | Прямое сопоставление. |
| `description` | `storage.description` | Прямое сопоставление. |
| `id` | `storage.external_id` | Прямое сопоставление. |
| (рассчитанное) | `storage.size` | Можно рассчитать общий размер, суммируя `backup_size` по всем `resources`. |
| (статическое) | `storage.type` | Можно установить в "Объектное", так как это хранилище бэкапов. |
| `DC` | `storage.location` | Прямое сопоставление ссылки. |
| `resources` | `seaf.ta.services.backup` | **Ключевая логика.** Каждый элемент в `resources` должен стать отдельной сущностью `backup`. |
| `tenant` | (нет) | Поле не имеет прямого аналога. |
| (нет) | `storage.iops`, `storage.throughput`, `storage.az` и др. | Эти поля нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Разделение на Хранилище и Бэкапы (Основная логика):**
    *   **Проблема:** `vault` содержит в себе и описание хранилища, и список резервных копий. Прямое сопоставление на `seaf.ta.services.storage` приведет к потере информации о том, *что* и *как* бэкапится.
    *   **Рекомендация (Архитектурно верная):** Использовать комбинированный подход:
        1.  **Создать `storage`:** Каждая сущность `vault` преобразуется в одну сущность `seaf.ta.services.storage`. Сюда переносятся `id`, `name`, `description`, `DC` и рассчитанный `size`.
        2.  **Создать `backup`:** Для **каждого** элемента в массиве `vault.resources` создается отдельная сущность `seaf.ta.services.backup`.
        3.  **Установить связи:**
            *   Каждая новая сущность `backup` должна ссылаться на `storage`, созданный на шаге 1 (через поле `backup.storage`).
            *   Каждая новая сущность `backup` должна ссылаться на соответствующий компонент, который она бэкапит (например, на `seaf.ta.components.server`), через поле `is_part_of_server`. ID компонента берется из `resources.id`.

2.  **Расчет размера (`size`):**
    *   **Логика:** Поле `size` в `storage` должно быть заполнено. Его можно рассчитать, суммировав поле `backup_size` для всех элементов в массиве `resources` исходного `vault`.

3.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию о `tenant` следует поместить в `description` создаваемого `storage`.

---

### vpc
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.vpcs`
- **Целевая сущность:** `seaf.ta.services.network_segment`
- **Описание сопоставления:** VPC (Virtual Private Cloud) — это логический контейнер для подсетей. Наиболее точно он сопоставляется с сущностью "Сетевой сегмент".

**Анализ сопоставления свойств:**

| Свойство в `vpc` | Свойство в `seaf.ta.services.network_segment` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `description` | `description` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `DC` | `location` | Прямое сопоставление ссылки. |
| `cidr` | `description` | CIDR самого VPC можно добавить в описание, т.к. у сегмента нет своего поля CIDR (оно есть у сетей внутри него). |
| `tenant` | (нет) | Поместить в `description`. |
| (нет) | `type` | Нужно будет заполнять на основе правил по умолчанию. |

**Ключевые моменты и рекомендации:**

1.  **Концептуальное моделирование (VPC как Сегмент, а не Маршрутизатор):**
    *   **Проблема:** Изначально предполагалось создавать две сущности из одного VPC (`network_segment` и `network` типа "Маршрутизатор"). Это создает ненужное дублирование и усложняет модель связей (например, для `peerings`).
    *   **Рекомендация:** Использовать более простой и чистый подход: **каждый `vpc` преобразуется только в одну сущность `seaf.ta.services.network_segment`**.
        *   Это правильно отражает логическую группировку сетей (`subnet` -> `network`).
        *   Функциональность маршрутизации между сетями внутри одного сегмента считается неявной (implicit) для данного уровня моделирования.
        *   Связи (`peering` -> `network_links`) могут быть установлены между сетями, входящими в разные сегменты, что сохраняет всю необходимую логику.

2.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию о `cidr` и `tenant` следует поместить в `description` для сохранения контекста.

---

### vpn connection
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.vpn_connections`
- **Целевая сущность:** `seaf.ta.services.logical_link`
- **Описание:** VPN-соединение — это сетевая связь между локальным VPN-шлюзом и удаленной точкой (офисом или другим ЦОД). Это идеально сопоставляется с сущностью `logical_link`.

**Анализ сопоставления свойств:**

| Свойство в `vpn_connections` | Свойство в `seaf.ta.services.logical_link` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `gw_id` | `source` | **Ключевая логика.** VPN-шлюз становится источником связи. Необходимо найти сущность `seaf.ta.components.network` (VPN-шлюз), найденный по `gw_id`, и поместить ссылку на нее. |
| `branch_id` | `target` | **Ключевая логика.** Удаленная точка (офис или ЦОД) становится приемником связи. Необходимо найти сущность `seaf.ta.services.office` или `seaf.ta.services.dc`, найденный по `branch_id`, и поместить ссылку на нее в массив. |
| (статическое значение) | `direction` | Установить в "<==>" (двунаправленная связь). |
| `remote_gw_ip`, `remote_subnets` | `description` | Эту информацию можно поместить в описание для полноты картины. |
| `tenant`, `DC` | (нет) | Поместить в `description`. |

**Рекомендация:**
Преобразовывать каждую сущность `vpn_connection` в отдельную сущность `seaf.ta.services.logical_link`, чтобы корректно моделировать сетевые связи между площадками.

---

### vpn gateway
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.vpn_gateways`
- **Целевая сущность:** `seaf.ta.components.network` (с типом "VPN")
- **Описание сопоставления:** VPN-шлюз отображается в сущность "Сетевое устройство".

**Анализ сопоставления свойств:**

| Свойство в `vpn_gateways` | Свойство в `seaf.ta.components.network` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` / `fqdn` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| (статическое значение) | `type` | Установить в "VPN". |
| `subnet_id` | `subnets` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `ip_address`, `type` (IPSec), `tenant`, `DC` | (нет) | Эти поля не имеют прямых аналогов. |
| `vpc_id` | `segment` | **Ключевая логика.** Необходимо найти `network_segment`, соответствующий `vpc_id`, и сослаться на него. |
| (нет) | `ports`, `az`, `virtualization` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Связь с VPC (`vpc_id`):**
    *   **Логика:** Поле `vpc_id` не отображается напрямую в свойство сетевого устройства. Оно подтверждает принадлежность `subnet_id` к правильному сетевому сегменту (`network_segment`), который создается из VPC.

2.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию о `ip_address`, типе VPN (`IPSec`), `tenant` и `DC` следует поместить в `description` для сохранения контекста.

3.  **Заполнение обязательных полей:**
    *   **Рекомендация:** Необходимо определить логику заполнения полей `az` и `virtualization`. `az` можно определить по `subnet_id`, а `virtualization` — на основе `DC` или общих правил.
