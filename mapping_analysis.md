# Анализ сопоставления моделей
# Описание и цели документа
**Цель:**
Этот документ представляет собой детальный анализ сопоставления (маппинга) между сущностями из облачной платформы (источник) и целевой метамоделью архитектуры SEAF. Основная задача — выявить концептуальные несостыковки, определить
логику преобразования данных и дать рекомендации для автоматической конвертации.
**Назначение:**
Анализ и рекомендации, изложенные в этом документе, предназначены для дальнейшего использования в качестве контекста для моделей ИИ (LLM), которые будут выполнять задачу по автоматической конвертации данных из одного представления
в другое.
**Источники данных:**
1.  **Исходные сущности (примеры данных):** Данные из `architecture/ta/reverse/cloud.ru/advanced/*.yaml`.
2.  **Схемы исходных сущностей:** Метамодель, описанная в `_metamodel_/iaas/cloud.ru/advanced/entities/*.yaml`.
3.  **Целевые сущности:** Метамодель архитектурного фреймворка SEAF, описанная в `_metamodel_/seaf-core/entities/ta/**/*.yaml`.

---

### Общая логика определения размещения

С актуальной версии конвертера большинство полей `location`, `availabilityzone`, `segment` вычисляются автоматически с помощью вспомогательного агрегатора `LocationResolver`. Он объединяет подсказки из разных сущностей (подсети, VPC, серверы, кластеры, явные поля `DC`/`AZ`) и возвращает единообразный набор ссылок на `seaf.ta.services.dc`, `seaf.ta.services.dc_az` и предопределённые сегменты. Благодаря этому отпала необходимость дублировать алгоритмы в каждом модуле, а итоговые YAML-данные становятся согласованными.

---

### tenant
- **Сущность-источник:** `tenant` (атрибут в различных сущностях)
- **Целевая сущность:** Не конвертируется.
- **Описание сопоставления:** Информация о тенанте используется для группировки ресурсов, но не преобразуется в отдельную сущность в целевой модели.
- **Возможные несостыковки:** Отсутствуют, так как прямого сопоставления нет.
- **Рекомендации:** Нет.

---

### branches
- **Сущность-источник:** `seaf.ta.reverse.cloud.ru.advanced.branches`
- **Целевая сущность:** `seaf.ta.services.office`
- **Описание сопоставления:** `branch_id` в `seaf.ta.reverse.cloud_ru.advanced.vpn_connections` ссылается на офисы, описанные в `seaf.ta.reverse.cloud.ru.advanced.branches`.

**Анализ сопоставления свойств:**

| Свойство в `branches` | Свойство в `seaf.ta.services.office` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `location` | `address` | Прямое сопоставление. `location` из `branches` можно записать в `address`. |
| `id` | `external_id` | `id` из `branches` можно использовать как внешний идентификатор. |
| `country`, `city` | `region` (ссылка на `seaf.ta.services.dc_region`) | **Несостыковка.** В `office` используется ссылка на регион, а в `branches` — отдельные поля для страны и города. |
| `symbol` | (нет) | Это свойство относится к визуализации и не имеет аналога в целевой модели данных. |
| (нет) | `description` | В `branches` нет поля для описания. |

**Ключевые несостыковки и рекомендации:**

1.  **Структура адреса:**
    *   **Проблема:** `branches` использует три поля (`country`, `city`, `location`), тогда как `office` использует одно поле `address` и ссылку на `region`.
    *   **Рекомендация:** При конвертации можно объединить `country`, `city`, `location` в одну строку и записать в `address`. Для поля `region` потребуется дополнительная логика: нужно будет найти или создать соответствующий объект `seaf.ta.services.dc_region` на основе данных из `country` и `city`.

2.  **Отсутствующие поля:**
    *   **Проблема:** В `branches` нет поля `description`.
    *   **Рекомендация:** При конвертации поле `description` в `office` останется пустым, если не будет введено вручную.

---

### dc_az
- **Сущность-источник:** Различные сущности (ecss, cces, rdss, dmss)
- **Целевая сущность:** `seaf.ta.services.dc_az`
- **Описание сопоставления:** Зоны доступности (AZ) из различных облачных ресурсов собираются и преобразуются в отдельные сущности `dc_az`.

**Анализ сопоставления свойств:**

| Свойство в источнике | Свойство в `seaf.ta.services.dc_az` | Комментарий |
| :--- | :--- | :--- |
| `az_name` (из ecss.az, cces.masters_az, rdss.az, dmss.available_az) | `title` | Прямое сопоставление. |
| `az_name` | `external_id` | Прямое сопоставление. |
| (статическое значение) | `vendor` | Установить в "Cloud.ru". |
| `az_name` | `region` | **Ключевая логика.** Регион вычисляется из имени AZ (например, `ru-moscow-1c` -> `ru-moscow-1`). Необходимо найти или создать соответствующую сущность `seaf.ta.services.dc_region`. |

**Ключевые моменты и рекомендации:**

1.  **Сбор уникальных AZ:**
    *   **Логика:** AZ могут встречаться в различных сущностях. Необходимо собрать все уникальные имена AZ из `ecss.az`, `ecss.disks.az`, `cces.masters_az`, `rdss.az`, `dmss.available_az`.
    *   **Рекомендация:** Создать отдельный конвертер (`dc_az_converter.py`), который будет агрегировать эти данные.

2.  **Вычисление региона:**
    *   **Логика:** Имя региона не всегда явно присутствует в исходных данных, но может быть выведено из имени AZ.
    *   **Рекомендация:** Реализовать функцию для извлечения имени региона из имени AZ (например, отбросить последнюю букву, если она является частью обозначения зоны).

3.  **Создание `dc_region`:**
    *   **Логика:** Сущность `dc_az` требует ссылку на `seaf.ta.services.dc_region`. Эти сущности также должны быть созданы.
    *   **Рекомендация:** Предполагается, что `dc_region` будут созданы отдельным конвертером или будут существовать заранее. Для текущей реализации, ссылка на `dc_region` будет формироваться по имени (например, `<prefix>.dc_region.ru-moscow-1`).

---

### cces
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.cces`
- **Целевая сущность:** `seaf.ta.services.k8s`
- **Описание сопоставления:** Кластеры Kubernetes из Cloud.ru (CCE) отображаются в сущность "Кластер Kubernetes" (`seaf.ta.services.k8s`).

**Анализ сопоставления свойств:**

| Свойство в `cces` | Свойство в `seaf.ta.services.k8s` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `alias` | `description` | Можно использовать `alias` для заполнения `description`. |
| `id` | `external_id` | Прямое сопоставление. |
| `endpoints` (url) | `fqdn` | Можно взять URL из `endpoints` в качестве FQDN. |
| `version` | `software` | Можно составить строку, например, "CCE " + `version`. |
| `DC` | `location` | **Изменено:** Теперь `location` формируется на основе `masters_az` и ссылается на автоматически созданный ЦОД (например, `<prefix>.dc.ru-moscow-1a`). |
| `subnet_id` | `network_connection` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `service_network` | `management_networks` | Необходимо создать `seaf.ta.services.network` на основе CIDR и сформировать массив из одной ссылки. |
| `supportistio` | `service_mesh` | Можно установить значение `service_mesh` в "istio", если `supportistio` равно `true`. |
| `authentication` | `auth` | Необходимо найти/создать объект `seaf.ta.services.kb` по строке `authentication` и сослаться на него. |
| `flavor`, `platform_version`, `addresses`, `security_groups`, `container_network`, `tenant` | (нет) | Эти поля не имеют прямых аналогов в целевой сущности. |
| (нет) | `is_own`, `cni`, `cluster_autoscaler`, `keys`, `idm`, `policy`, `pam`, `ca`, `audit`, `audit_policy`, `monitoring`, `backup`, `registries` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Связь с сегментом:**
    *   **Логика:** Кластер привязывается к предопределенному сегменту `INT-NET` своего ЦОДа. ЦОД определяется по `availability_zone` подсети (`subnet_id`), к которой подключен кластер.

2.  **Преобразование ссылок:**
    *   **Логика:** Для полей `masters_az`, `subnet_id`, `service_network`, `authentication` требуется логика поиска/создания целевых объектов (`dc_az`, `network`, `kb`) и формирования на них ссылок.

3.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию из `cces`, не имеющую аналогов (например, `flavor`, `platform_version`), можно поместить в поле `description`. Поля в `k8s`, для которых нет данных в `cces` (например, `cni`, `monitoring`), должны быть заполнены вручную или на основе правил по умолчанию (например, `is_own: true`).

---

### dmss
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.dmss`
- **Целевая сущность:** `seaf.ta.services.cluster`
- **Описание сопоставления:** Сервис очередей (Kafka/RabbitMQ) отображается в общий кластер с соответствующим `service_type`.

**Анализ сопоставления свойств:**

| Свойство в `dmss` | Свойство в `seaf.ta.services.cluster` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `engine` | `service_type` | Установить `service_type` в "Интеграционная шина (MQ, ETL, API)". Значение `engine` (rabbitmq/kafka) поместить в `description`. |
| `address` | `fqdn` | Можно использовать IP-адрес в качестве FQDN. |
| `available_az` | `availabilityzone` | Необходимо найти объекты `seaf.ta.services.dc_az` по строковым именам и сформировать массив ссылок. |
| `DC` | `location` | **Изменено:** Теперь `location` формируется на основе `available_az` и ссылается на автоматически созданный ЦОД (например, `<prefix>.dc.ru-moscow-1a`). |
| `subnet_id` | `network_connection` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `type` | `reservation_type` | `type` (например, "single") можно сопоставить с `reservation_type`. |
1.  **Связь с сегментом:**
    *   **Логика:** Кластер привязывается к предопределенному сегменту `INT-NET` своего ЦОДа. ЦОД определяется по `available_az` самого сервиса.

2.  **Преобразование ссылок:**
    *   **Логика:** Для полей `available_az` и `subnet_id` требуется логика поиска/создания целевых объектов (`dc_az`, `network`) и формирования на них ссылок.

3.  **Детализация в описании:**
    *   **Рекомендация:** Большое количество специфичных для `dmss` атрибутов (версии, хранилище, спецификации) следует поместить в поле `description` в структурированном виде (например, Markdown) для сохранения полноты информации.

---

### dc_region
- **Сущность-источник:** Различные сущности (ecss, cces, rdss, dmss) через AZ
- **Целевая сущность:** `seaf.ta.services.dc_region`
- **Описание сопоставления:** Регионы, выведенные из имен зон доступности (AZ), преобразуются в отдельные сущности `dc_region`.

**Анализ сопоставления свойств:**

| Свойство в источнике | Свойство в `seaf.ta.services.dc_region` | Комментарий |
| :--- | :--- | :--- |
| `region_name` (выведен из AZ) | `title` | Прямое сопоставление. |
| `region_name` | `external_id` | Прямое сопоставление. |

**Ключевые моменты и рекомендации:**

1.  **Сбор уникальных регионов:**
    *   **Логика:** Регионы выводятся из имен AZ, которые встречаются в различных сущностях. Необходимо собрать все уникальные имена регионов.
    *   **Рекомендация:** Создать отдельный конвертер (`dc_region_converter.py`), который будет агрегировать эти данные.

2.  **Вычисление региона:**
    *   **Логика:** Имя региона выводится из имени AZ (например, `ru-moscow-1c` -> `ru-moscow-1`).
    *   **Рекомендация:** Использовать ту же логику вывода региона, что и для `dc_az`.

---

### dc_az
- **Сущность-источник:** Различные сущности (ecss, cces, rdss, dmss)
- **Целевая сущность:** `seaf.ta.services.dc_az`
- **Описание сопоставления:** Зоны доступности (AZ) из различных облачных ресурсов собираются и преобразуются в отдельные сущности `dc_az`.

**Анализ сопоставления свойств:**

| Свойство в источнике | Свойство в `seaf.ta.services.dc_az` | Комментарий |
| :--- | :--- | :--- |
| `az_name` (из ecss.az, cces.masters_az, rdss.az, dmss.available_az) | `title` | Прямое сопоставление. |
| `az_name` | `external_id` | Прямое сопоставление. |
| (статическое значение) | `vendor` | Установить в "Cloud.ru". |
| `az_name` | `region` | **Ключевая логика.** Регион вычисляется из имени AZ (например, `ru-moscow-1c` -> `ru-moscow-1`). Необходимо найти или создать соответствующую сущность `seaf.ta.services.dc_region`. |

**Ключевые моменты и рекомендации:**

1.  **Сбор уникальных AZ:**
    *   **Логика:** AZ могут встречаться в различных сущностях. Необходимо собрать все уникальные имена AZ из `ecss.az`, `ecss.disks.az`, `cces.masters_az`, `rdss.az`, `dmss.available_az`.
    *   **Рекомендация:** Создать отдельный конвертер (`dc_az_converter.py`), который будет агрегировать эти данные.

2.  **Вычисление региона:**
    *   **Логика:** Имя региона не всегда явно присутствует в исходных данных, но может быть выведено из имени AZ.
    *   **Рекомендация:** Реализовать функцию для извлечения имени региона из имени AZ (например, отбросить последнюю букву, если она является частью обозначения зоны).

3.  **Создание `dc_region`:**
    *   **Логика:** Сущность `dc_az` требует ссылку на `seaf.ta.services.dc_region`. Эти сущности также должны быть созданы.
    *   **Рекомендация:** Предполагается, что `dc_region` будут созданы отдельным конвертером или будут существовать заранее. Для текущей реализации, ссылка на `dc_region` будет формироваться по имени (например, `<prefix>.dc_region.ru-moscow-1`).

### ecss
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.ecss`
- **Целевая сущность:** `seaf.ta.components.server`
- **Описание сопоставления:** Виртуальные машины (Elastic Cloud Server) отображаются в сущность "Сервер".

**Анализ сопоставления свойств:**

| Свойство в `ecss` | Свойство в `seaf.ta.components.server` | Комментарий |
| :--- | :--- | :--- |
| `name` | `fqdn` / `title` | Прямое сопоставление. |
| `description` | `description` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `os.type`, `os.bit` | `os.type`, `os.bit` | Прямое сопоставление. |
| `cpu.cores`, `cpu.frequency` | `cpu.cores`, `cpu.frequency` | Прямое сопоставление. |
| `ram` | `ram` | Необходимо конвертировать MB в GB (разделить на 1024). |
| `nic_qty` | `nic_qty` | Прямое сопоставление. |
| `disks` | `disks` | Структура объектов в массиве разная, требуется приведение к единому формату. |
| `az` | `az` | Необходимо найти объект `seaf.ta.services.dc_az` по строковому имени и поместить ссылку в массив. |
| `subnets` | `subnets` | Для каждого ID из `ecss.subnets` нужно найти/создать `seaf.ta.services.network` и добавить ссылку в массив. |
| `type` | `type` | Прямое сопоставление (`vm` -> "Виртуальный"). |
| (статическое значение) | `is_part_of_cluster_virtualization` | Ссылка на единый кластер виртуализации. |
| `flavor`, `status`, `addresses`, `security_groups`, `tags`, `tenant`, `DC` | (нет) | Эти поля не имеют прямых аналогов в целевой сущности. |
| (нет) | `virtualization`, `is_part_of_...`, `software` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Связь с сегментом:**
    *   **Логика:** Сервер привязывается к предопределенному сегменту `INT-NET` своего ЦОДа. ЦОД определяется по `az` самого сервера.

2.  **Преобразование данных и ссылок:**
    *   **Логика:** Необходимо реализовать конвертацию `ram` (MB в GB), а также логику поиска целевых объектов для `az` и `subnets` для формирования ссылок.

3.  **Детализация в описании:**
    *   **Рекомендация:** Важную информацию без прямых аналогов (`flavor`, `status`, `tags` и др.) следует поместить в `description` в структурированном виде. Поле `virtualization` (обязательное) нужно будет заполнить на основе `DC` или общих правил.

---

### cluster_virtualization
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.ecss` (неявно, через AZ и сети ВМ)
- **Целевая сущность:** `seaf.ta.services.cluster_virtualization`
- **Описание сопоставления:** Единый кластер виртуализации создается для всех виртуальных машин.

**Анализ сопоставления свойств:**

| Свойство в источнике | Свойство в `seaf.ta.services.cluster_virtualization` | Комментарий |
| :--- | :--- | :--- |
| (статическое значение) | `title` | Установить в "Cloud.ru Virtualization Cluster". |
| (статическое значение) | `external_id` | Установить в "cloud_ru_virtualization_cluster". |
| (статическое значение) | `hypervisor` | Установить в "Cloud.ru Hypervisor". |
| `ecss.az`, `ecss.disks.az` | `availabilityzone` | Собрать все уникальные AZ из всех ВМ и дисков, преобразовать в ссылки на `dc_az`. |
| `ecss.subnets` | `network_connection` | Собрать все уникальные сетевые подключения (подсети) из всех ВМ, преобразовать в ссылки на `network`. |
| (нет) | `oversubscription_rate`, `drs_support`, `sdrs_support`, `location` | Эти поля не имеют прямых аналогов в источнике. |

**Ключевые моменты и рекомендации:**

1.  **Единый кластер:**
    *   **Логика:** Создается только одна сущность `cluster_virtualization` для всего облака.
    *   **Рекомендация:** Реализовать отдельный конвертер (`cluster_virtualization_converter.py`), который будет агрегировать эти данные.

2.  **Связь с ВМ:**
    *   **Логика:** Каждая ВМ (`ecss`) должна ссылаться на этот кластер виртуализации.
    *   **Рекомендация:** В конвертере `ecss` добавить поле `is_part_of_cluster_virtualization` со ссылкой на созданный кластер.

---

### eips
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.eips`
- **Целевые сущности:** `seaf.ta.services.network` (тип WAN), `seaf.ta.services.network_links`
- **Описание сопоставления:** Elastic IP (публичный IP-адрес) рассматривается как внешняя сеть (WAN), а связь с внутренними ресурсами отражается отдельным сетевым линком.

**Анализ сопоставления свойств:**

| Свойство в `eips` | Свойство в `seaf.ta.services.network` | Комментарий |
| :--- | :--- | :--- |
| `ext_address` | `title` | Можно использовать внешний IP в качестве имени. |
| `id` | `external_id` | Прямое сопоставление. |
| `ext_address` | `wan_ip` | Прямое сопоставление. |
| (статическое значение) | `type` | Установить в "WAN". |
| `int_address` | `segment` | **Ключевая логика.** Сегмент определяется по `int_address`. Сначала по IP-адресу находится подсеть и ее зона доступности (AZ). Если EIP публичный, он привязывается к сегменту `INTERNET` данного AZ. Если EIP приватный — к сегменту `INT-NET`. |
| `int_address`, `DC` | `location` | `LocationResolver` определяет ссылки на ЦОДы по найденной подсети, связанным ресурсам и (при необходимости) полю `DC`. |
| `limit.throughput` | `description` | Пропускную способность и другие детали можно добавить в описание. |
| `type`, `port_id`, `int_address`, `tenant`, `DC` | `description` | Эти поля не имеют прямых аналогов и могут быть добавлены в описание для полноты. |

| Свойство в `eips` | Свойство в `seaf.ta.services.network_links` | Комментарий |
| :--- | :--- | :--- |
| `id` | `external_id` | Линку присваивается `id` с постфиксом `-link`. |
| `ext_address` | `title` | Используется для понятного имени связи. |
| `int_address` | `network_connection` | Формируется массив из WAN-сети и всех внутренних сущностей (сервер, NAT, ELB), у которых совпадает IP адрес. |

**Ключевые моменты и рекомендации:**

1.  **Вычисление сегмента:**
    *   **Логика:** Связь EIP с сегментом сети определяется через его внутренний IP-адрес (`int_address`). `LocationResolver` находит соответствующую подсеть и её AZ, далее в зависимости от публичности `ext_address` EIP привязывается к `INTERNET` или `INT-NET`.
    *   **Рекомендация:** Использовать стандартную библиотеку `ipaddress` для проверки CIDR и публичности IP, передавая результаты в `LocationResolver`.

2.  **Связывание с внутренними ресурсами:**
    *   **Логика:** Поле `int_address` указывает на IP внутри VPC, который принадлежит конкретному серверу (`ecss`), NAT-шлюзу или балансировщику. Необходимо построить сетевой линк `seaf.ta.services.network_links`, включающий WAN-сеть EIP и найденные сущности.
    *   **Рекомендация:** Использовать индекс по внутренним адресам, собранным из `ecss.addresses`, `nat_gateways.address` и `elbs.address`. При совпадении IP формировать линк с понятным заголовком и типом `EIP`.

---

### elbs
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.elbs`
- **Целевая сущность:** `seaf.ta.services.compute_service` (категория «Шлюз, Балансировщик, прокси»)
- **Описание сопоставления:** Балансировщик нагрузки (Elastic Load Balance) представлен как сервис уровня приложений. Это позволяет сохранять информацию о конфигурации и устраняет ограничения визуализации в `SEAF2DrawIO`.

**Анализ сопоставления свойств:**

| Свойство в `elbs` | Свойство в `seaf.ta.services.compute_service` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `description`, `listeners`, `pools`, `tenant`, `DC` | `description` | Структуры `listeners`/`pools` сериализуются (JSON) и добавляются в описание для сохранения деталей. |
| `id` | `external_id` | Прямое сопоставление. |
| `address` | `fqdn` | Внутренний IP используется как FQDN. |
| `availability_zone`, `subnet_id`, связанные ресурсы | `availabilityzone`, `location` | Список AZ и ЦОД вычисляется автоматически через `LocationResolver`, который агрегирует подсказки из подсетей и связанных сервисов. |
| `subnet_id` | `network_connection` | Содержит ссылку на сеть, в которой размещён балансировщик. |
| (статическое значение) | `service_type` | Устанавливается в «Шлюз, Балансировщик, прокси». |

**Ключевые моменты и рекомендации:**

1.  **Конфигурация балансировщика (`listeners`, `pools`):**
    *   **Практика:** Поскольку метамодель SEAF не описывает эти сущности отдельно, их сериализуют в `description` (JSON/Markdown). Это позволяет сохранить всю информацию, пусть и без структурированного API.

2.  **Определение расположения:**
    *   **Логика:** Вместо ручного определения AZ/ЦОД используется `LocationResolver`. Он объединяет подсказки из подсетей, связанных VPC и самих ELB, фильтруя дубликаты и шумовые значения.

3.  **Отображение на диаграмме:**
    *   **Результат:** Перенос ELB в `compute_service` устранил предупреждения генератора диаграмм и позволил размещать балансировщики на страницах сервисов (вместо слоя сетевых устройств).

---

### nat_gateways
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.nat_gateways`
- **Целевая сущность:** `seaf.ta.components.network` (с типом "NAT")
- **Описание сопоставления:** NAT-шлюз отображается в сущность "Сетевое устройство".

**Анализ сопоставления свойств:**

| Свойство в `nat_gateways` | Свойство в `seaf.ta.components.network` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` / `fqdn` | Прямое сопоставление. |
| `description` | `description` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| (статическое значение) | `type` | Установить в "NAT". |
| `subnet_id` | `subnets` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `snat_rules`, `dnat_rules` | (нет) | **Ключевая несостыковка.** Это сложная конфигурация, определяющая логику работы NAT-шлюза. |
| `subnet_id` (через `subnets`->`az`) | `segment` | **Ключевая логика.** Устройство привязывается к предопределенному сегменту `INT-NET` своего ЦОДа. ЦОД определяется по `availability_zone` подсети, к которой подключен шлюз. |
| `availability_zone` (через подсеть) | `location` | На основании подсказок (подсети, связанные ресурсы, явный `DC`) `LocationResolver` формирует набор ссылок на `<prefix>.dc.*`. |
| `address`, `status`, `tenant`, `DC` | (нет) | Эти поля не имеют прямых аналогов. |
| (нет) | `ports`, `az`, `virtualization`, `software` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Правила NAT (`snat_rules`, `dnat_rules`):**
    *   **Проблема:** Аналогично `elbs`, ключевая информация о работе шлюза — его правила SNAT и DNAT — не имеет полей в целевой сущности `seaf.ta.components.network`.
    *   **Рекомендация 1 (Простая):** Поместить всю структуру правил в поле `description` в формате YAML или JSON. Это сохранит данные, но сделает их труднодоступными для автоматического анализа.
    *   **Рекомендация 2 (Сложная, но более корректная):** Расширить метамодель, добавив сущности для правил NAT (например, `seaf.ta.components.network.nat_rule`) и связав их с `seaf.ta.components.network`.

2.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию без прямых аналогов (`address`, `status`, `tenant`) переносить в `description`. Ссылки на ЦОД автоматически формирует `LocationResolver`, поэтому `DC` вручную дублировать не нужно.

3.  **Заполнение обязательных полей:**
    *   **Рекомендация:** Поддерживать актуальность данных по подсетям: именно они позволяют `LocationResolver` корректно вычислить `location` и `segment` без дополнительной логики в модуле.

---

### peerings
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.peerings`
- **Целевая сущность:** `seaf.ta.services.network_links`
- **Описание сопоставления:** VPC Peering (связь между двумя VPC) отображается как сетевой линк между виртуальными маршрутизаторами, представляющими каждую VPC. Такой подход соответствует логике `network_links` и позволяет визуализировать пиринговые соединения без дублирования `logical_link`.

**Анализ сопоставления свойств:**

| Свойство в `peerings` | Свойство в `seaf.ta.services.network_links` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `description`, `status`, `tenant`, `DC` | `description` | Переносятся в свободный текст (каждое значение с новой строки). |
| `id` | `external_id` | Прямое сопоставление. |
| `request_vpc`, `accept_vpc` | `network_connection` | **Ключевая логика.** Оба поля преобразуются в ссылки на маршрутизаторы `<prefix>.vpcs.<vpc_id>.router`. Линк создаётся только если найдены обе конечные точки. |
| (статическое значение) | `technology` | Устанавливается в "VPC Peering". |

**Ключевые моменты и рекомендации:**

1.  **Разрешение конечных точек:**
    *   **Логика:** Поскольку маршрутизаторы создаются из конвертера VPC по предсказуемому правилу (`<prefix>.vpcs.<vpc_id>.router`), линк можно сформировать без дополнительного поиска в данных. При отсутствии одной из сторон соединение не создаётся.

2.  **Описание:**
    *   **Рекомендация:** В `description` переносить `status`, `tenant`, `DC` и другие вспомогательные поля, чтобы сохранить контекст соединения.

---

### rdss
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.rdss`
- **Целевая сущность:** `seaf.ta.services.cluster` (с типом "СУБД")
- **Описание сопоставления:** Реляционная БД как сервис (RDS) отображается в сущность "Кластер".

**Анализ сопоставления свойств:**

| Свойство в `rdss` | Свойство в `seaf.ta.services.cluster` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `private_ips` | `fqdn` | Можно взять первый IP из массива в качестве FQDN. |
| `type` | `reservation_type` | `type` (например, "Single", "HA") можно сопоставить с `reservation_type`. |
| (статическое значение) | `service_type` | Установить в "СУБД". |
| `az` | `availabilityzone` | Необходимо найти объект `seaf.ta.services.dc_az` по строковому имени и поместить ссылку в массив. |
| `DC` | `location` | **Изменено:** Теперь `location` формируется на основе `az` и ссылается на автоматически созданный ЦОД (например, `<prefix>.dc.ru-moscow-1a`). |
| `subnet_id` | `network_connection` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `datastore`, `volume`, `nodes`, `backup_strategy`, `flavor`, `status`, `public_ips`, `switch_strategy`, `tags`, `tenant` | (нет) | **Ключевая несостыковка.** Большое количество специфичной информации о СУБД. |

**Ключевые моменты и рекомендации:**

1.  **Связь с сегментом:**
    *   **Логика:** Кластер привязывается к предопределенному сегменту `INT-NET` своего ЦОДа. ЦОД определяется по `availability_zone` его нод.

2.  **Детализация СУБД (`datastore`, `nodes`, `volume` и др.):**
    *   **Проблема:** Целевая сущность `cluster` является обобщенной и не содержит полей для специфичной информации о кластере баз данных (тип и версия движка, информация о нодах, дисках, бэкапах).
    *   **Рекомендация:** Всю эту структурированную информацию (`datastore`, `nodes`, `volume`, `backup_strategy`, `flavor`) следует поместить в поле `description` в формате YAML или Markdown. Это позволит сохранить все детали, не усложняя основную модель `cluster`.

3.  **Преобразование ссылок (`az`, `subnet_id`):**
    *   **Логика:** Как и в предыдущих случаях, для полей `az` и `subnet_id` требуется логика поиска соответствующих целевых объектов (`dc_az`, `network`) и формирования на них ссылок.

4.  **Отсутствующие поля:**
    *   **Рекомендация:** Остальную информацию без прямых аналогов (`status`, `tags`, `tenant` и т.д.) также следует добавить в `description`.

---

### security_group
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.security_groups`
- **Целевая сущность:** Нет прямого аналога.
- **Описание:** Группы безопасности представляют собой именованные наборы правил сетевого доступа (stateful firewall), которые применяются к сетевым интерфейсам компонентов (серверов, кластеров и т.д.).

**Проблема:**
В метамодели `seaf-core` отсутствует сущность, которая бы напрямую соответствовала "группе сетевых правил" или "политике межсетевого экрана". Простое игнорирование этой информации приведет к потере критически важных данных о сетевой безопасности.

**Предлагаемые решения:**

#### Вариант 1: Сохранение в описании компонента (Простой)
- **Логика:** Для каждого компонента (`server`, `k8s` и т.д.), к которому применяется `security_group`, найти все правила из этой группы. Сформатировать эти правила в виде таблицы (Markdown) или блока YAML/JSON и добавить в поле `description` соответствующего компонента (`seaf.ta.components.server` и др.).
- **Плюсы:**
    - Легко реализовать.
    - Вся информация сохраняется.
- **Минусы:**
    - **Дублирование данных:** Если одна группа применяется к 100 серверам, ее правила будут 100 раз скопированы.
    - **Неструктурированные данные:** Правила хранятся как текст, что делает невозможным автоматический анализ и запросы (например, "найти все серверы, открытые для мира по порту 22").

#### Вариант 2: Создание новой сущности (Архитектурно верный)
- **Логика:** Расширить метамодель `seaf-core`, добавив новую сущность, например, `seaf.ta.services.firewall_policy`.
    - Эта сущность будет содержать поля `title`, `description` и массив `rules`.
    - Структура правил будет повторять исходную: `direction`, `protocol`, `port`, `remote_ip` и т.д.
    - Компоненты, такие как `server`, получат новое свойство (например, `firewall_policies`), которое будет содержать массив ссылок на эти новые сущности политик.
- **Плюсы:**
    - Корректно моделирует предметную область.
    - Исключает дублирование данных.
    - Позволяет выполнять запросы и анализ правил.
- **Минусы:**
    - Требует изменения основной метамодели, что может быть нежелательно.

#### Вариант 3: Использование `seaf.ta.services.kb` (Компромисс)
- **Логика:** Использовать существующую сущность "База знаний по ИБ" (`seaf.ta.services.kb`).
    - Каждая `security_group` преобразуется в один объект `seaf.ta.services.kb` с определенным типом (например, `type: "Firewall Policy"`).
    - Название и ID группы безопасности сопоставляются с `title` и `external_id`.
    - Сами правила (`rules`) в формате YAML/JSON помещаются в поле `description` этого объекта `kb`.
    - Компоненты (`server` и др.) ссылаются на эти объекты `kb` через существующее поле `integrations` или новое специализированное поле.
- **Плюсы:**
    - Использует существующую метамодель.
    - Избегает дублирования данных.
- **Минусы:**
    - Правила все еще хранятся как неструктурированный текст в `description`, что затрудняет анализ.

**Итоговая рекомендация:**
- **Для долгосрочного развития** архитектурной модели **Вариант 2** является наиболее предпочтительным.
- **Для быстрой реализации** в рамках текущей задачи, если изменение метамодели невозможно, можно использовать **Вариант 1** или **Вариант 3**. Вариант 3 чуть лучше, так как избегает дублирования правил.

---

### subnet
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.subnets`
- **Целевая сущность:** `seaf.ta.services.network` (с типом LAN)
- **Описание сопоставления:** Подсеть VPC отображается в сущность "Сеть" с типом LAN.

**Анализ сопоставления свойств:**

| Свойство в `subnets` | Свойство в `seaf.ta.services.network` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `description` | `description` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `cidr` | `ipnetwork` | Прямое сопоставление. |
| (статическое значение) | `type` | Установить в "LAN". |
| `availability_zone` | `segment` | **Ключевая логика.** Сеть привязывается к предопределенному сегменту `INT-NET` своего ЦОДа. ЦОД определяется по `availability_zone` подсети. |
| `gateway`, `dns_list`, `tenant`, `DC` | (нет) | Эти поля не имеют прямых аналогов. |
| (нет) | `vlan`, `is_management`, `is_own`, `provider`, `throughput`, `redundancy` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Связь с сегментом (`availability_zone` -> `segment`):**
    *   **Логика:** `subnet` является частью предопределенного сегмента `INT-NET`. Привязка осуществляется на основе зоны доступности (`availability_zone`) самой подсети.
    *   **Рекомендация:** При конвертации извлечь `availability_zone` подсети, определить по ней ЦОД и сформировать ссылку на соответствующий сегмент `INT-NET` (например, `<prefix>.segment.<az_name>.INT-NET`).

2.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию о `gateway`, `dns_list`, `tenant` и `DC` следует поместить в `description` для сохранения контекста.

---

### vaults
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.vaults`
- **Целевая сущность:** `seaf.ta.services.storage` и `seaf.ta.services.backup`
- **Описание сопоставления:** `vault` представляет собой одновременно и хранилище для резервных копий, и информацию о самих копиях. Это требует комбинированного подхода при конвертации.

**Анализ сопоставления свойств:**

| Свойство в `vaults` | Свойство в целевых сущностях | Комментарий |
| :--- | :--- | :--- |
| `name` | `storage.title` | Прямое сопоставление. |
| `description` | `storage.description` | Прямое сопоставление. |
| `id` | `storage.external_id` | Прямое сопоставление. |
| (рассчитанное) | `storage.size` | Можно рассчитать общий размер, суммируя `backup_size` по всем `resources`. |
| (статическое) | `storage.type` | Можно установить в "Объектное", так как это хранилище бэкапов. |
| `DC` | `storage.location` | Прямое сопоставление ссылки. |
| `resources` | `seaf.ta.services.backup` | **Ключевая логика.** Каждый элемент в `resources` должен стать отдельной сущностью `backup`. |
| `tenant` | (нет) | Поле не имеет прямого аналога. |
| (нет) | `storage.iops`, `storage.throughput`, `storage.az` и др. | Эти поля нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Разделение на Хранилище и Бэкапы (Основная логика):**
    *   **Проблема:** `vault` содержит в себе и описание хранилища, и список резервных копий. Прямое сопоставление на `seaf.ta.services.storage` приведет к потере информации о том, *что* и *как* бэкапится.
    *   **Рекомендация (Архитектурно верная):** Использовать комбинированный подход:
        1.  **Создать `storage`:** Каждая сущность `vault` преобразуется в одну сущность `seaf.ta.services.storage`. Сюда переносятся `id`, `name`, `description`, `DC` и рассчитанный `size`.
        2.  **Создать `backup`:** Для **каждого** элемента в массиве `vault.resources` создается отдельная сущность `seaf.ta.services.backup`.
        3.  **Установить связи:**
            *   Каждая новая сущность `backup` должна ссылаться на `storage`, созданный на шаге 1 (через поле `backup.storage`).
            *   Каждая новая сущность `backup` должна ссылаться на соответствующий компонент, который она бэкапит (например, на `seaf.ta.components.server`), через поле `is_part_of_server`. ID компонента берется из `resources.id`.

2.  **Расчет размера (`size`):**
    *   **Логика:** Поле `size` в `storage` должно быть заполнено. Его можно рассчитать, суммировав поле `backup_size` для всех элементов в массиве `resources` исходного `vault`.

3.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию о `tenant` следует поместить в `description` создаваемого `storage`.

---

### vpc
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.vpcs`
- **Целевые сущности:** `seaf.ta.components.network` (тип "Маршрутизатор")
- **Описание сопоставления:** VPC (Virtual Private Cloud) само по себе не преобразуется в отдельную сущность. Вместо этого для каждой VPC создаётся виртуальный маршрутизатор, который служит центральной точкой сети. С 2024 года его размещение (`location` и `segment`) определяется через агрегатор подсказок (`LocationResolver`), собирающий информацию о подсетях, серверах, кластерах и других ресурсах VPC.

**Анализ сопоставления свойств:**

| Свойство в `vpc` | Свойство в `seaf.ta.components.network` (маршрутизатор) | Комментарий |
| :--- | :--- | :--- |
| `name`, `id` | `title`, `description` | Имя и ID VPC используются для формирования `title` и `description` маршрутизатора. |
| `id` | `external_id` | Прямое сопоставление. |
| (рассчитано) | `segment` | **Ключевая логика.** Маршрутизатор привязывается к сегменту `INT-NET` каждого ЦОДа, где обнаружены ресурсы VPC. Список сегментов определяется автоматически. |
| (рассчитано) | `network_connection` | Заполняется ссылками на все сети (`seaf.ta.services.network`), чей CIDR входит в CIDR VPC. |
| `DC`, `AZ` и другие подсказки | `location` | Список ЦОД формируется на основе всех обнаруженных подсказок (подсети, серверы, кластеры, ручной `DC`). Дубликаты и неинформативные значения (например, голые числа) отфильтровываются. |

**Ключевые моменты и рекомендации:**

1.  **Маршрутизатор как представитель VPC:**
    *   Для каждой VPC создаётся сущность `seaf.ta.components.network` с типом `Маршрутизатор`. Её `external_id` совпадает с ID VPC.
    *   Свойства `location` и `segment` заполняются автоматически на основании всех связанных сущностей (подсети, ECS, CCE, RDS, DMS и т.д.).
    *   Свойство `network_connection` маршрутизатора агрегирует все подсети, входящие в CIDR данного VPC.

---

### vpn connection
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.vpn_connections`
- **Целевая сущность:** `seaf.ta.services.logical_link`
- **Описание:** VPN-соединение — это сетевая связь между локальным VPN-шлюзом и удаленной точкой (офисом или другим ЦОД). Это идеально сопоставляется с сущностью `logical_link`.

**Анализ сопоставления свойств:**

| Свойство в `vpn_connections` | Свойство в `seaf.ta.services.logical_link` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| `gw_id` | `source` | **Ключевая логика.** VPN-шлюз становится источником связи. Необходимо найти сущность `seaf.ta.components.network` (VPN-шлюз), найденный по `gw_id`, и поместить ссылку на нее. |
| `branch_id` | `target` | **Ключевая логика.** Удаленная точка (офис или ЦОД) становится приёмником связи. Если объект найден в целевой модели, ссылка на него (или на соответствующий сетевой сегмент) попадает в массив `target`. Внешние площадки без описания в данных не конвертируются. |
| (статическое значение) | `direction` | Установить в "<==>" (двунаправленная связь). |
| `remote_gw_ip`, `remote_subnets` | `description` | Эту информацию можно поместить в описание для полноты картины. |
| `tenant`, `DC` | (нет) | Поместить в `description`. |

**Рекомендация:**
Преобразовывать каждую сущность `vpn_connection` в отдельную сущность `seaf.ta.services.logical_link`, но создавать связь только при наличии обеих конечных точек (шлюз + офис/ЦОД/сегмент). Это избавляет диаграммы от предупреждений о недостающих объектах.

---

### vpn gateway
- **Сущность-источник:** `seaf.ta.reverse.cloud_ru.advanced.vpn_gateways`
- **Целевая сущность:** `seaf.ta.components.network` (с типом "VPN")
- **Описание сопоставления:** VPN-шлюз отображается в сущность "Сетевое устройство".

**Анализ сопоставления свойств:**

| Свойство в `vpn_gateways` | Свойство в `seaf.ta.components.network` | Комментарий |
| :--- | :--- | :--- |
| `name` | `title` / `fqdn` | Прямое сопоставление. |
| `id` | `external_id` | Прямое сопоставление. |
| (статическое значение) | `type` | Установить в "VPN". |
| `subnet_id` | `subnets` | Необходимо найти `seaf.ta.services.network` по `subnet_id` и сформировать массив из одной ссылки. |
| `ip_address`, `type` (IPSec), `tenant`, `DC` | (нет) | Эти поля не имеют прямых аналогов. `DC` добавляется в описание. |
| `availability_zone` (через подсеть, ВМ) | `location` | Определяет `LocationResolver`, который объединяет подсказки из подсетей, связанных VPC и самого шлюза. |
| `vpc_id` (через `subnet_id`->`az`) | `segment` | **Ключевая логика.** Устройство привязывается к предопределенному сегменту `INT-NET` своего ЦОДа. ЦОД определяется по `availability_zone` подсети, к которой подключен шлюз. |
| (нет) | `ports`, `az`, `virtualization` | Эти поля в целевой сущности нужно будет заполнять на основе дополнительной логики или вручную. |

**Ключевые моменты и рекомендации:**

1.  **Связь с VPC (`vpc_id`):**
    *   **Логика:** Поле `vpc_id` не отображается напрямую в свойство сетевого устройства. Оно подтверждает принадлежность `subnet_id` к правильному сетевому сегменту (`network_segment`), который создается из VPC.

2.  **Отсутствующие поля:**
    *   **Рекомендация:** Информацию о `ip_address`, типе VPN (`IPSec`), `tenant` и `DC` следует поместить в `description` для сохранения контекста.

3.  **Заполнение обязательных полей:**
    *   **Рекомендация:** Поля `location` и `segment` теперь формируются автоматически через `LocationResolver`; достаточно передавать корректные `subnet_id` и связанные AZ. `virtualization` задаётся по общему правилу ("Виртуальный").
